<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Translator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .image-upload {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 400px;
            margin: 20px 0;
            border: 2px dashed #ccc;
            border-radius: 8px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .grids-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .grid-title {
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input, .control-group select {
            width: 100px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .selected-color-info {
            margin-top: 10px;
            text-align: center;
        }
        
        .color-count {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .color-count-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .color-count-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 4px;
            background: #f8f8f8;
        }
        
        .color-count-swatch {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        
        .color-count-info {
            flex-grow: 1;
            font-size: 14px;
        }
        
        .palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 10px;
            min-width: 272px; /* 8 columns * (30px + 4px gap) */
        }
        
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: #ff6b6b;
            border-width: 3px;
        }
        
        .mosaic-grid {
            display: inline-block;
            border: 2px solid #333;
            background: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .mosaic-row {
            display: flex;
        }
        
        .mosaic-cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .mosaic-cell.reference {
            cursor: default;
        }
        
        .mosaic-cell:hover {
            border-color: #ff6b6b;
        }
        
        .mosaic-cell.reference:hover {
            border-color: #ddd;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 5px;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .button.secondary {
            background: #2196F3;
        }
        
        .button.secondary:hover {
            background: #1976D2;
        }

        .toggle-view {
            margin: 20px 0;
            text-align: center;
        }

        .toggle-button {
            background: #4a90e2;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .toggle-button:hover {
            background: #357abd;
        }

        .toggle-button.showing-original {
            background: #e24a4a;
        }

        .toggle-button.showing-original:hover {
            background: #bd3535;
        }

        .mosaic-cell.showing-original {
            transition: background-color 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mosaic Translator</h1>
            <p>Load an image and translate it into tile choices</p>
        </div>
        
        <div class="image-upload">
            <input type="file" id="imageInput" accept="image/*">
            <br><br>
            <img id="imagePreview" class="image-preview" style="display: none;">
        </div>
        
        <div class="controls">
            <div class="toggle-view">
                <button id="toggleView" class="toggle-button" onclick="toggleView()">
                    Show Original Image
                </button>
            </div>
            
            <div class="control-group">
                <label>Color Palette:</label>
                <div class="palette" id="colorPalette">
                    <!-- Color swatches will be generated here -->
                </div>
            </div>
            
            <div class="control-group">
                <label>Selected Color:</label>
                <div id="selectedColor" style="width: 50px; height: 30px; border: 2px solid #333; border-radius: 4px; background: #fff;"></div>
                <div class="selected-color-info">
                    <span id="selectedColorName">Off White</span>
                </div>
                <div class="current-color-info" style="margin-top: 10px; font-size: 12px; color: #666;">
                    <div>RGB: <span id="selectedColorRGB">232, 232, 228</span></div>
                    <div>Index: <span id="selectedColorIndex">0</span></div>
                </div>
            </div>

            <div class="control-group">
                <label>Current Color:</label>
                <div id="currentColor" style="width: 50px; height: 30px; border: 2px solid #333; border-radius: 4px; background: #fff;"></div>
                <div class="current-color-info">
                    <span id="currentColorName">-</span>
                </div>
                <div class="current-color-info" style="margin-top: 10px; font-size: 12px; color: #666;">
                    <div>RGB: <span id="currentColorRGB">-</span></div>
                    <div>Index: <span id="currentColorIndex">-</span></div>
                </div>
            </div>

            <div class="control-group">
                <button id="undoButton" class="button secondary" onclick="undo()" disabled>Undo</button>
                <button class="button" onclick="saveProgress()">Save Progress</button>
                <button class="button secondary" onclick="loadProgress()">Load Progress</button>
            </div>
        </div>
        
        <div class="grids-container">
            <div class="grid-wrapper">
                <div class="grid-title">Original Image</div>
                <div id="referenceContainer">
                    <!-- Reference grid will be generated here -->
                </div>
            </div>
            
            <div class="grid-wrapper">
                <div class="grid-title">Tile Picker</div>
                <div id="mosaicContainer">
                    <!-- Mosaic grid will be generated here -->
                </div>
            </div>
        </div>
        
        <div class="color-count">
            <h3>Tile Count by Color</h3>
            <div id="colorCountGrid" class="color-count-grid">
                <!-- Color counts will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const WHITE_THRESHOLD = 10; // LAB Delta-E threshold for considering a color as white
        const TILE_SIZE = 20; // Size of each tile in pixels
        
        // Tile palette definition
        const tilePalette = [
            { slug: "off-white", name: "Off White", rgb: [232, 232, 228] },
            { slug: "light-gray", name: "Light Gray", rgb: [201, 201, 196] },
            { slug: "medium-gray", name: "Medium Gray", rgb: [170, 170, 164] },
            { slug: "warm-gray", name: "Warm Gray", rgb: [140, 140, 134] },
            { slug: "dark-gray", name: "Dark Gray", rgb: [110, 110, 104] },
            { slug: "charcoal", name: "Charcoal", rgb: [80, 80, 74] },
            { slug: "deep-charcoal", name: "Deep Charcoal", rgb: [60, 60, 54] },
            { slug: "pure-white", name: "Pure White", rgb: [255, 255, 255] },
            { slug: "black", name: "Black", rgb: [0, 0, 0] },
            { slug: "beige", name: "Beige", rgb: [194, 180, 153] },
            { slug: "taupe", name: "Taupe", rgb: [160, 140, 110] },
            { slug: "brown", name: "Brown", rgb: [120, 100, 70] },
            { slug: "dark-brown", name: "Dark Brown", rgb: [70, 50, 30] },
            { slug: "pale-green", name: "Pale Green", rgb: [200, 220, 210] },
            { slug: "sage", name: "Sage", rgb: [120, 180, 160] },
            { slug: "deep-green", name: "Deep Green", rgb: [60, 120, 100] },
            { slug: "light-blue", name: "Light Blue", rgb: [180, 210, 230] },
            { slug: "blue", name: "Blue", rgb: [100, 150, 200] },
            { slug: "navy", name: "Navy", rgb: [40, 80, 140] },
            { slug: "peach", name: "Peach", rgb: [230, 200, 180] },
            { slug: "terracotta", name: "Terracotta", rgb: [200, 140, 120] },
            { slug: "red", name: "Red", rgb: [180, 60, 40] },
            { slug: "yellow", name: "Yellow", rgb: [255, 220, 0] },
            { slug: "orange", name: "Orange", rgb: [255, 150, 0] }
        ];
        
        // State variables
        let selectedColorSlug = tilePalette[0].slug;
        let imageData = null;
        let colorCounts = Object.fromEntries(tilePalette.map(color => [color.slug, 0]));
        let originalColors = new Map();
        let undoStack = [];
        let currentGridState = new Map();
        let showingOriginal = false;
        
        // Selection variables
        let isSelecting = false;
        let selectionStart = null;
        let selectionOverlay = null;
        
        // LAB color conversion functions
        function rgbToLab(r, g, b) {
            // Convert RGB to XYZ
            let x, y, z;
            r = r / 255;
            g = g / 255;
            b = b / 255;
            
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            
            x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
            y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
            z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
            
            // Convert XYZ to Lab
            x = x / 95.047;
            y = y / 100.000;
            z = z / 108.883;
            
            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
            
            return [
                (116 * y) - 16,    // L
                500 * (x - y),     // a
                200 * (y - z)      // b
            ];
        }
        
        // Calculate color difference in LAB space (Delta E)
        function labColorDistance(lab1, lab2) {
            return Math.sqrt(
                Math.pow(lab1[0] - lab2[0], 2) +
                Math.pow(lab1[1] - lab2[1], 2) +
                Math.pow(lab1[2] - lab2[2], 2)
            );
        }
        
        // Find the closest tile color for a given RGB color
        function findClosestTileColor(targetRgb) {
            // Convert target color to LAB
            const targetLab = rgbToLab(...targetRgb);
            
            // Check if it's close enough to white
            const whiteLab = rgbToLab(255, 255, 255);
            if (labColorDistance(targetLab, whiteLab) < WHITE_THRESHOLD) {
                return tilePalette.findIndex(color => 
                    color.rgb[0] === 255 && color.rgb[1] === 255 && color.rgb[2] === 255
                );
            }
            
            let minDistance = Infinity;
            let closestIndex = 0;
            
            tilePalette.forEach((color, index) => {
                const distance = labColorDistance(targetLab, rgbToLab(...color.rgb));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });
            
            return closestIndex;
        }
        
        // Process image and create mosaic grid
        function processImage(img) {
            // Create canvas to read image data
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match image
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            // Draw image to canvas
            ctx.drawImage(img, 0, 0);
            
            // Get image data
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Calculate grid dimensions based on aspect ratio
            const aspectRatio = canvas.width / canvas.height;
            const baseHeight = 67; // Fixed height
            const gridWidth = Math.round(baseHeight * aspectRatio);
            const gridHeight = baseHeight;
            
            // Create both grids
            createReferenceGrid(gridWidth, gridHeight);
            createGrid(true, gridWidth, gridHeight);
        }
        
        // Update current color display when hovering over cells
        function updateCurrentColor(cell) {
            const bgcolor = cell.style.backgroundColor;
            if (bgcolor) {
                // Parse RGB values from the background-color
                const rgb = bgcolor.match(/\d+/g).map(Number);
                const colorIndex = findClosestTileColor(rgb);
                const color = tilePalette[colorIndex];
                const colorName = color.name;

                // Update current color display
                const currentColorDiv = document.getElementById('currentColor');
                const currentColorNameSpan = document.getElementById('currentColorName');
                const currentColorRGBSpan = document.getElementById('currentColorRGB');
                const currentColorIndexSpan = document.getElementById('currentColorIndex');

                currentColorDiv.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                currentColorNameSpan.textContent = colorName;
                currentColorRGBSpan.textContent = `${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]}`;
                currentColorIndexSpan.textContent = colorIndex;
            }
        }

        // Reset current color display when not hovering
        function resetCurrentColor() {
            const currentColorDiv = document.getElementById('currentColor');
            const currentColorNameSpan = document.getElementById('currentColorName');
            const currentColorRGBSpan = document.getElementById('currentColorRGB');
            const currentColorIndexSpan = document.getElementById('currentColorIndex');

            currentColorDiv.style.backgroundColor = '#fff';
            currentColorNameSpan.textContent = '-';
            currentColorRGBSpan.textContent = '-';
            currentColorIndexSpan.textContent = '-';
        }

        // Create reference grid showing original image
        function createReferenceGrid(width, height) {
            const container = document.getElementById('referenceContainer');
            container.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = 'mosaic-grid';
            
            for (let row = 0; row < height; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'mosaic-row';
                
                for (let col = 0; col < width; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'mosaic-cell reference';
                    
                    if (imageData) {
                        // Calculate the corresponding pixel position
                        const imgX = Math.floor((col / width) * imageData.width);
                        const imgY = Math.floor((row / height) * imageData.height);
                        const pixelIndex = (imgY * imageData.width + imgX) * 4;
                        
                        // Get pixel color
                        const pixelColor = [
                            imageData.data[pixelIndex],
                            imageData.data[pixelIndex + 1],
                            imageData.data[pixelIndex + 2]
                        ];
                        
                        cell.style.backgroundColor = `rgb(${pixelColor[0]}, ${pixelColor[1]}, ${pixelColor[2]})`;
                        
                        // Add hover events for eyedropper
                        cell.addEventListener('mouseenter', () => updateCurrentColor(cell));
                        cell.addEventListener('mouseleave', resetCurrentColor);
                    }
                    
                    rowDiv.appendChild(cell);
                }
                
                grid.appendChild(rowDiv);
            }
            
            container.appendChild(grid);
        }
        
        // Initialize color palette
        function initColorPalette() {
            console.log('Initializing color palette...'); // Debug log
            const palette = document.getElementById('colorPalette');
            if (!palette) {
                console.error('Color palette element not found!');
                return;
            }
            
            palette.innerHTML = '';
            
            tilePalette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (index === selectedColorIndex ? ' selected' : '');
                swatch.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                swatch.onclick = () => selectColor(index);
                palette.appendChild(swatch);
                console.log(`Created swatch for color ${color.name}`); // Debug log
            });
        }
        
        // Select a color from the palette
        function selectColor(index) {
            console.log(`Selecting color: ${tilePalette[index].name}`); // Debug log
            selectedColorSlug = tilePalette[index].slug;
            
            // Update visual selection
            document.querySelectorAll('.color-swatch').forEach((swatch, i) => {
                swatch.classList.toggle('selected', i === index);
            });
            
            // Update selected color display and name
            const color = tilePalette[index];
            const colorName = color.name;
            const selectedColorDiv = document.getElementById('selectedColor');
            const selectedColorNameSpan = document.getElementById('selectedColorName');
            const selectedColorRGBSpan = document.getElementById('selectedColorRGB');
            const selectedColorIndexSpan = document.getElementById('selectedColorIndex');
            
            if (selectedColorDiv && selectedColorNameSpan && selectedColorRGBSpan && selectedColorIndexSpan) {
                selectedColorDiv.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                selectedColorNameSpan.textContent = colorName;
                selectedColorRGBSpan.textContent = `${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]}`;
                selectedColorIndexSpan.textContent = index;
            } else {
                console.error('Selected color display elements not found!');
            }
        }
        
        // Handle image upload
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('imagePreview');
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    
                    // Wait for image to load before processing
                    preview.onload = () => processImage(preview);
                };
                reader.readAsDataURL(file);
            }
        });
        
        function updateColorCounts() {
            // Reset all color counts
            tilePalette.forEach(color => {
                colorCounts[color.slug] = 0;
            });

            const cells = document.querySelectorAll('#mosaicContainer .mosaic-cell');
            let totalCount = 0;
            
            cells.forEach(cell => {
                const bgcolor = cell.style.backgroundColor;
                if (bgcolor) {
                    // Parse RGB values from the background-color
                    const rgb = bgcolor.match(/\d+/g).map(Number);
                    const colorIndex = findClosestTileColor(rgb);
                    colorCounts[tilePalette[colorIndex].slug]++;
                    totalCount++;
                }
            });
            
            // Update the color count display
            const countGrid = document.getElementById('colorCountGrid');
            countGrid.innerHTML = '';
            
            tilePalette.forEach(color => {
                if (colorCounts[color.slug] > 0) {
                    const countItem = document.createElement('div');
                    countItem.className = 'color-count-item';
                    
                    const swatch = document.createElement('div');
                    swatch.className = 'color-count-swatch';
                    swatch.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                    
                    const info = document.createElement('div');
                    info.className = 'color-count-info';
                    info.textContent = `${color.name}: ${colorCounts[color.slug]}`;
                    
                    countItem.appendChild(swatch);
                    countItem.appendChild(info);
                    countGrid.appendChild(countItem);
                }
            });

            // Add total count at the bottom
            const totalCountItem = document.createElement('div');
            totalCountItem.className = 'color-count-item';
            totalCountItem.style.gridColumn = '1 / -1';  // Span all columns
            totalCountItem.style.justifyContent = 'center';
            totalCountItem.style.fontWeight = 'bold';
            totalCountItem.style.marginTop = '10px';
            totalCountItem.style.borderTop = '2px solid #ccc';
            totalCountItem.style.paddingTop = '10px';
            totalCountItem.textContent = `Total Tiles: ${totalCount}`;
            countGrid.appendChild(totalCountItem);
        }
        
        function toggleView() {
            showingOriginal = !showingOriginal;
            const button = document.getElementById('toggleView');
            const cells = document.querySelectorAll('#mosaicContainer .mosaic-cell');
            
            button.textContent = showingOriginal ? 'Show Tile Colors' : 'Show Original Image';
            button.classList.toggle('showing-original', showingOriginal);
            
            cells.forEach(cell => {
                const pos = cell.dataset.position;
                if (pos && originalColors.has(pos)) {
                    if (showingOriginal) {
                        // Store current tile color
                        cell.dataset.tileColor = cell.style.backgroundColor;
                        // Show original color with slight transparency
                        const origColor = originalColors.get(pos);
                        cell.style.backgroundColor = `rgba(${origColor[0]}, ${origColor[1]}, ${origColor[2]}, 0.85)`;
                    } else {
                        // Restore tile color
                        cell.style.backgroundColor = cell.dataset.tileColor || cell.style.backgroundColor;
                    }
                }
                cell.classList.toggle('showing-original', showingOriginal);
            });
        }
        
        // Selection handling
        function createSelectionOverlay() {
            removeSelectionOverlay(); // Remove any existing overlay
            selectionOverlay = document.createElement('div');
            selectionOverlay.style.position = 'fixed'; // Changed from absolute to fixed
            selectionOverlay.style.border = '2px solid #ff6b6b';
            selectionOverlay.style.backgroundColor = 'rgba(255, 107, 107, 0.2)';
            selectionOverlay.style.pointerEvents = 'none';
            selectionOverlay.style.zIndex = '1000';
            document.body.appendChild(selectionOverlay);
        }
        
        function updateSelectionOverlay(startCell, currentCell) {
            if (!selectionOverlay) return;
            
            const startRect = startCell.getBoundingClientRect();
            const currentRect = currentCell.getBoundingClientRect();
            
            const left = Math.min(startRect.left, currentRect.left);
            const top = Math.min(startRect.top, currentRect.top);
            const right = Math.max(startRect.right, currentRect.right);
            const bottom = Math.max(startRect.bottom, currentRect.bottom);
            
            selectionOverlay.style.left = left + 'px';
            selectionOverlay.style.top = top + 'px';
            selectionOverlay.style.width = (right - left) + 'px';
            selectionOverlay.style.height = (bottom - top) + 'px';
        }
        
        function removeSelectionOverlay() {
            if (selectionOverlay) {
                selectionOverlay.remove();
                selectionOverlay = null;
            }
        }
        
        function getCellsInSelection(startCell, endCell) {
            const grid = document.getElementById('mosaicContainer');
            const cells = Array.from(grid.getElementsByClassName('mosaic-cell'));
            
            const startPos = startCell.dataset.position.split('-').map(Number);
            const endPos = endCell.dataset.position.split('-').map(Number);
            
            const minRow = Math.min(startPos[0], endPos[0]);
            const maxRow = Math.max(startPos[0], endPos[0]);
            const minCol = Math.min(startPos[1], endPos[1]);
            const maxCol = Math.max(startPos[1], endPos[1]);
            
            return cells.filter(cell => {
                const [row, col] = cell.dataset.position.split('-').map(Number);
                return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;
            });
        }
        
        // Modified selection handling to support undo
        function pushUndoState(changes) {
            undoStack.push(changes);
            document.getElementById('undoButton').disabled = false;
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            const lastChange = undoStack.pop();
            lastChange.forEach(({position, previousColorIndex}) => {
                const [row, col] = position.split('-').map(Number);
                const cell = document.querySelector(`[data-position="${position}"]`);
                if (cell && previousColorIndex !== undefined) {
                    const color = tilePalette[previousColorIndex];
                    cell.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                    currentGridState.set(position, previousColorIndex);
                }
            });
            
            updateColorCounts();
            document.getElementById('undoButton').disabled = undoStack.length === 0;
        }
        
        // Save/Load functionality
        function saveProgress() {
            // Convert current state to use slugs instead of indices
            const gridState = Array.from(currentGridState.entries()).map(([pos, index]) => [pos, tilePalette[index].slug]);
            
            const saveData = {
                version: 1,  // Adding version for future compatibility
                gridState: gridState,
                dimensions: {
                    width: document.querySelector('.mosaic-row').children.length,
                    height: document.querySelector('.mosaic-grid').children.length
                }
            };
            
            const blob = new Blob([JSON.stringify(saveData)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'mosaic_progress.json';
            a.style.display = 'none';
            document.body.appendChild(a);
            
            // Trigger the save dialog
            if (window.showSaveFilePicker) {
                // Use modern file system API if available
                const opts = {
                    suggestedName: 'mosaic_progress.json',
                    types: [{
                        description: 'JSON File',
                        accept: {'application/json': ['.json']}
                    }]
                };
                
                window.showSaveFilePicker(opts)
                    .then(handle => handle.createWritable())
                    .then(writable => {
                        writable.write(blob)
                            .then(() => writable.close())
                            .then(() => console.log('File saved successfully'));
                    })
                    .catch(err => {
                        // Fall back to simple download if user cancels or browser doesn't support the API
                        console.log('Falling back to simple download');
                        a.click();
                    });
            } else {
                // Fall back to simple download for browsers that don't support the file system API
                a.click();
            }
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 0);
        }
        
        function loadProgress() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = event => {
                    try {
                        const saveData = JSON.parse(event.target.result);
                        
                        // First create an empty grid without auto-population
                        createGrid(false, saveData.dimensions.width, saveData.dimensions.height);
                        
                        // Clear current state
                        currentGridState.clear();
                        
                        // Convert saved slugs back to indices and restore the state
                        saveData.gridState.forEach(([position, colorSlug]) => {
                            const colorIndex = tilePalette.findIndex(color => color.slug === colorSlug);
                            if (colorIndex !== -1) {
                                const cell = document.querySelector(`[data-position="${position}"]`);
                                if (cell) {
                                    const color = tilePalette[colorIndex];
                                    cell.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                                    currentGridState.set(position, colorIndex);
                                }
                            } else {
                                console.warn(`Color slug "${colorSlug}" not found in palette`);
                            }
                        });
                        
                        updateColorCounts();
                    } catch (error) {
                        console.error('Error loading save file:', error);
                        alert('Error loading save file. Please make sure it\'s a valid mosaic save file.');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        // Modified paintCell to support undo
        function paintCell(cell) {
            const position = cell.dataset.position;
            const previousColorIndex = currentGridState.get(position);
            const colorIndex = tilePalette.findIndex(color => color.slug === selectedColorSlug);
            const color = tilePalette[colorIndex];
            
            cell.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
            currentGridState.set(position, colorIndex);
            
            return { position, previousColorIndex };
        }
        
        // Modified createGrid to handle loading saved state properly
        function createGrid(autoPopulate = false, width = null, height = null) {
            const gridWidth = width || 42;
            const gridHeight = height || 67;
            
            // Only clear the state if we're not loading a saved state
            if (autoPopulate) {
                currentGridState.clear();
                undoStack.length = 0;
                document.getElementById('undoButton').disabled = true;
            }
            
            const container = document.getElementById('mosaicContainer');
            container.innerHTML = '';
            
            // Only clear original colors if we're creating a new grid
            if (autoPopulate) {
                originalColors.clear();
            }
            
            const grid = document.createElement('div');
            grid.className = 'mosaic-grid';
            
            // Add container-level event handlers
            grid.addEventListener('mouseleave', () => {
                if (isSelecting) {
                    isSelecting = false;
                    removeSelectionOverlay();
                }
            });
            
            for (let row = 0; row < gridHeight; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'mosaic-row';
                
                for (let col = 0; col < gridWidth; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'mosaic-cell';
                    const pos = `${row}-${col}`;
                    cell.dataset.position = pos;
                    
                    // Add hover events for eyedropper
                    cell.addEventListener('mouseenter', () => {
                        updateCurrentColor(cell);
                        if (isSelecting) {
                            updateSelectionOverlay(selectionStart, cell);
                        }
                    });
                    cell.addEventListener('mouseleave', resetCurrentColor);
                    
                    // Mouse event handlers for selection
                    cell.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return; // Left click only
                        isSelecting = true;
                        selectionStart = cell;
                        createSelectionOverlay();
                        updateSelectionOverlay(cell, cell);
                        e.preventDefault(); // Prevent text selection
                    });
                    
                    cell.addEventListener('mouseup', (e) => {
                        if (!isSelecting) return;
                        const selectedCells = getCellsInSelection(selectionStart, cell);
                        const changes = selectedCells.map(selectedCell => paintCell(selectedCell));
                        pushUndoState(changes);
                        isSelecting = false;
                        removeSelectionOverlay();
                        updateColorCounts();
                        e.stopPropagation(); // Prevent document handler from firing
                    });
                    
                    // Single-click handling
                    cell.addEventListener('click', (e) => {
                        if (!isSelecting && e.button === 0) {
                            const change = [paintCell(cell)];
                            pushUndoState(change);
                            updateColorCounts();
                        }
                    });
                    
                    if (autoPopulate && imageData) {
                        const imgX = Math.floor((col / gridWidth) * imageData.width);
                        const imgY = Math.floor((row / gridHeight) * imageData.height);
                        const pixelIndex = (imgY * imageData.width + imgX) * 4;
                        
                        const pixelColor = [
                            imageData.data[pixelIndex],
                            imageData.data[pixelIndex + 1],
                            imageData.data[pixelIndex + 2]
                        ];
                        
                        originalColors.set(pos, pixelColor);
                        
                        const closestColorIndex = findClosestTileColor(pixelColor);
                        const tileColor = tilePalette[closestColorIndex];
                        cell.style.backgroundColor = `rgb(${tileColor.rgb[0]}, ${tileColor.rgb[1]}, ${tileColor.rgb[2]})`;
                        currentGridState.set(pos, closestColorIndex);
                    }
                    
                    rowDiv.appendChild(cell);
                }
                
                grid.appendChild(rowDiv);
            }
            
            container.appendChild(grid);
            updateColorCounts();
        }
        
        // Add global mouse event handlers
        document.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                removeSelectionOverlay();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            
            // Find the cell under the cursor
            const cell = document.elementFromPoint(e.clientX, e.clientY);
            if (cell && cell.classList.contains('mosaic-cell') && !cell.classList.contains('reference')) {
                updateSelectionOverlay(selectionStart, cell);
            }
        });
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...'); // Debug log
            createGrid();
            initColorPalette();
        });
    </script>
</body>
</html> 