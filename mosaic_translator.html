<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Translator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .image-upload {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 400px;
            margin: 20px 0;
            border: 2px dashed #ccc;
            border-radius: 8px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .grids-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .grid-title {
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-group input, .control-group select {
            width: 100px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .selected-color-info {
            margin-top: 10px;
            text-align: center;
        }
        
        .color-count {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .color-count-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .color-count-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 4px;
            background: #f8f8f8;
        }
        
        .color-count-swatch {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        
        .color-count-info {
            flex-grow: 1;
            font-size: 14px;
        }
        
        .palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 10px;
        }
        
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: #ff6b6b;
            border-width: 3px;
        }
        
        .mosaic-grid {
            display: inline-block;
            border: 2px solid #333;
            background: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .mosaic-row {
            display: flex;
        }
        
        .mosaic-cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .mosaic-cell.reference {
            cursor: default;
        }
        
        .mosaic-cell:hover {
            border-color: #ff6b6b;
        }
        
        .mosaic-cell.reference:hover {
            border-color: #ddd;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .toggle-view {
            margin: 20px 0;
            text-align: center;
        }

        .toggle-button {
            background: #4a90e2;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .toggle-button:hover {
            background: #357abd;
        }

        .toggle-button.showing-original {
            background: #e24a4a;
        }

        .toggle-button.showing-original:hover {
            background: #bd3535;
        }

        .mosaic-cell.showing-original {
            transition: background-color 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mosaic Translator</h1>
            <p>Load an image and translate it into tile choices</p>
        </div>
        
        <div class="image-upload">
            <input type="file" id="imageInput" accept="image/*">
            <br><br>
            <img id="imagePreview" class="image-preview" style="display: none;">
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="gridSize">Base Grid Size:</label>
                <input type="number" id="gridSize" value="42" min="5" max="100">
                <div style="margin-top: 5px; font-size: 12px; color: #666;">
                    Grid will maintain image aspect ratio
                </div>
                <button class="button" onclick="createGrid()">Create Grid</button>
            </div>
            
            <div class="toggle-view">
                <button id="toggleView" class="toggle-button" onclick="toggleView()">
                    Show Original Image
                </button>
            </div>
            
            <div class="control-group">
                <label>Color Palette:</label>
                <div class="palette" id="colorPalette">
                    <!-- Color swatches will be generated here -->
                </div>
            </div>
            
            <div class="control-group">
                <label>Selected Color:</label>
                <div id="selectedColor" style="width: 50px; height: 30px; border: 2px solid #333; border-radius: 4px; background: #fff;"></div>
                <div class="selected-color-info">
                    <span id="selectedColorName">Off White</span>
                </div>
            </div>
        </div>
        
        <div class="grids-container">
            <div class="grid-wrapper">
                <div class="grid-title">Original Image</div>
                <div id="referenceContainer">
                    <!-- Reference grid will be generated here -->
                </div>
            </div>
            
            <div class="grid-wrapper">
                <div class="grid-title">Tile Picker</div>
                <div id="mosaicContainer">
                    <!-- Mosaic grid will be generated here -->
                </div>
            </div>
        </div>
        
        <div class="color-count">
            <h3>Tile Count by Color</h3>
            <div id="colorCountGrid" class="color-count-grid">
                <!-- Color counts will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const WHITE_THRESHOLD = 10; // LAB Delta-E threshold for considering a color as white
        const TILE_SIZE = 20; // Size of each tile in pixels
        
        // Tile colors from palette.py
        const tileColors = [
            [232, 232, 228], // Off White
            [201, 201, 196], // Light Gray
            [170, 170, 164], // Medium Gray
            [140, 140, 134], // Warm Gray
            [110, 110, 104], // Dark Gray
            [80, 80, 74],    // Charcoal
            [60, 60, 54],    // Deep Charcoal
            [255, 255, 255], // Pure White
            [0, 0, 0],       // Black
            [194, 180, 153], // Beige
            [160, 140, 110], // Taupe
            [120, 100, 70],  // Brown
            [70, 50, 30],    // Dark Brown
            [200, 220, 210], // Pale Green
            [120, 180, 160], // Sage
            [60, 120, 100],  // Deep Green
            [180, 210, 230], // Light Blue
            [100, 150, 200], // Blue
            [40, 80, 140],   // Navy
            [230, 200, 180], // Peach
            [200, 140, 120], // Terracotta
            [180, 60, 40],   // Red
            [255, 220, 0],   // Yellow
            [255, 150, 0]    // Orange
        ];
        
        const colorNames = [
            "Off White", "Light Gray", "Medium Gray", "Warm Gray",
            "Dark Gray", "Charcoal", "Deep Charcoal", "Pure White",
            "Black", "Beige", "Taupe", "Brown",
            "Dark Brown", "Pale Green", "Sage", "Deep Green",
            "Light Blue", "Blue", "Navy", "Peach",
            "Terracotta", "Red", "Yellow", "Orange"
        ];
        
        let selectedColorIndex = 0;
        let imageData = null;
        let colorCounts = new Array(tileColors.length).fill(0);
        let showingOriginal = false;
        let originalColors = new Map(); // Store original colors for each cell
        
        // Selection variables
        let isSelecting = false;
        let selectionStart = null;
        let selectionOverlay = null;
        
        // LAB color conversion functions
        function rgbToLab(r, g, b) {
            // Convert RGB to XYZ
            let x, y, z;
            r = r / 255;
            g = g / 255;
            b = b / 255;
            
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            
            x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
            y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
            z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
            
            // Convert XYZ to Lab
            x = x / 95.047;
            y = y / 100.000;
            z = z / 108.883;
            
            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
            
            return [
                (116 * y) - 16,    // L
                500 * (x - y),     // a
                200 * (y - z)      // b
            ];
        }
        
        // Calculate color difference in LAB space (Delta E)
        function labColorDistance(lab1, lab2) {
            return Math.sqrt(
                Math.pow(lab1[0] - lab2[0], 2) +
                Math.pow(lab1[1] - lab2[1], 2) +
                Math.pow(lab1[2] - lab2[2], 2)
            );
        }
        
        // Find the closest tile color for a given RGB color
        function findClosestTileColor(targetRgb) {
            // Convert target color to LAB
            const targetLab = rgbToLab(...targetRgb);
            
            // Check if it's close enough to white
            const whiteLab = rgbToLab(255, 255, 255);
            if (labColorDistance(targetLab, whiteLab) < WHITE_THRESHOLD) {
                return tileColors.findIndex(color => 
                    color[0] === 255 && color[1] === 255 && color[2] === 255
                );
            }
            
            let minDistance = Infinity;
            let closestIndex = 0;
            
            tileColors.forEach((tileRgb, index) => {
                const tileLab = rgbToLab(...tileRgb);
                const distance = labColorDistance(targetLab, tileLab);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = index;
                }
            });
            
            return closestIndex;
        }
        
        // Process image and create mosaic grid
        function processImage(img) {
            // Create canvas to read image data
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match image
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            // Draw image to canvas
            ctx.drawImage(img, 0, 0);
            
            // Get image data
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Calculate grid dimensions based on aspect ratio
            const aspectRatio = canvas.width / canvas.height;
            const baseHeight = 67; // Fixed height
            const gridWidth = Math.round(baseHeight * aspectRatio);
            const gridHeight = baseHeight;
            
            // Create both grids
            createReferenceGrid(gridWidth, gridHeight);
            createGrid(true, gridWidth, gridHeight);
        }
        
        // Create reference grid showing original image
        function createReferenceGrid(width, height) {
            const container = document.getElementById('referenceContainer');
            container.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = 'mosaic-grid';
            
            for (let row = 0; row < height; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'mosaic-row';
                
                for (let col = 0; col < width; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'mosaic-cell reference';
                    
                    if (imageData) {
                        // Calculate the corresponding pixel position
                        const imgX = Math.floor((col / width) * imageData.width);
                        const imgY = Math.floor((row / height) * imageData.height);
                        const pixelIndex = (imgY * imageData.width + imgX) * 4;
                        
                        // Get pixel color
                        const pixelColor = [
                            imageData.data[pixelIndex],
                            imageData.data[pixelIndex + 1],
                            imageData.data[pixelIndex + 2]
                        ];
                        
                        cell.style.backgroundColor = `rgb(${pixelColor[0]}, ${pixelColor[1]}, ${pixelColor[2]})`;
                    }
                    
                    rowDiv.appendChild(cell);
                }
                
                grid.appendChild(rowDiv);
            }
            
            container.appendChild(grid);
        }
        
        // Initialize color palette
        function initColorPalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            
            tileColors.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                swatch.onclick = () => selectColor(index);
                palette.appendChild(swatch);
            });
            
            selectColor(0);
        }
        
        function selectColor(index) {
            selectedColorIndex = index;
            
            // Update visual selection
            document.querySelectorAll('.color-swatch').forEach((swatch, i) => {
                swatch.classList.toggle('selected', i === index);
            });
            
            // Update selected color display and name
            const color = tileColors[index];
            const colorName = colorNames[index];
            document.getElementById('selectedColor').style.backgroundColor = 
                `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            document.getElementById('selectedColorName').textContent = colorName;
        }
        
        // Handle image upload
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('imagePreview');
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    
                    // Wait for image to load before processing
                    preview.onload = () => processImage(preview);
                };
                reader.readAsDataURL(file);
            }
        });
        
        function updateColorCounts() {
            colorCounts.fill(0);
            const cells = document.querySelectorAll('.mosaic-cell');
            
            cells.forEach(cell => {
                const bgcolor = cell.style.backgroundColor;
                if (bgcolor) {
                    // Parse RGB values from the background-color
                    const rgb = bgcolor.match(/\d+/g).map(Number);
                    const colorIndex = findClosestTileColor(rgb);
                    colorCounts[colorIndex]++;
                }
            });
            
            // Update the color count display
            const countGrid = document.getElementById('colorCountGrid');
            countGrid.innerHTML = '';
            
            colorCounts.forEach((count, index) => {
                if (count > 0) {
                    const countItem = document.createElement('div');
                    countItem.className = 'color-count-item';
                    
                    const swatch = document.createElement('div');
                    swatch.className = 'color-count-swatch';
                    const color = tileColors[index];
                    swatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    
                    const info = document.createElement('div');
                    info.className = 'color-count-info';
                    info.textContent = `${colorNames[index]}: ${count}`;
                    
                    countItem.appendChild(swatch);
                    countItem.appendChild(info);
                    countGrid.appendChild(countItem);
                }
            });
        }
        
        function toggleView() {
            showingOriginal = !showingOriginal;
            const button = document.getElementById('toggleView');
            const cells = document.querySelectorAll('.mosaic-cell');
            
            button.textContent = showingOriginal ? 'Show Tile Colors' : 'Show Original Image';
            button.classList.toggle('showing-original', showingOriginal);
            
            cells.forEach(cell => {
                const pos = cell.dataset.position;
                if (pos && originalColors.has(pos)) {
                    if (showingOriginal) {
                        // Store current tile color
                        cell.dataset.tileColor = cell.style.backgroundColor;
                        // Show original color with slight transparency
                        const origColor = originalColors.get(pos);
                        cell.style.backgroundColor = `rgba(${origColor[0]}, ${origColor[1]}, ${origColor[2]}, 0.85)`;
                    } else {
                        // Restore tile color
                        cell.style.backgroundColor = cell.dataset.tileColor;
                    }
                }
                cell.classList.toggle('showing-original', showingOriginal);
            });
        }
        
        // Selection handling
        function createSelectionOverlay() {
            selectionOverlay = document.createElement('div');
            selectionOverlay.style.position = 'absolute';
            selectionOverlay.style.border = '2px solid #ff6b6b';
            selectionOverlay.style.backgroundColor = 'rgba(255, 107, 107, 0.2)';
            selectionOverlay.style.pointerEvents = 'none';
            document.body.appendChild(selectionOverlay);
        }
        
        function updateSelectionOverlay(startCell, currentCell) {
            if (!selectionOverlay) return;
            
            const startRect = startCell.getBoundingClientRect();
            const currentRect = currentCell.getBoundingClientRect();
            
            const left = Math.min(startRect.left, currentRect.left);
            const top = Math.min(startRect.top, currentRect.top);
            const right = Math.max(startRect.right, currentRect.right);
            const bottom = Math.max(startRect.bottom, currentRect.bottom);
            
            selectionOverlay.style.left = left + 'px';
            selectionOverlay.style.top = top + 'px';
            selectionOverlay.style.width = (right - left) + 'px';
            selectionOverlay.style.height = (bottom - top) + 'px';
        }
        
        function removeSelectionOverlay() {
            if (selectionOverlay) {
                selectionOverlay.remove();
                selectionOverlay = null;
            }
        }
        
        function getCellsInSelection(startCell, endCell) {
            const grid = document.getElementById('mosaicContainer');
            const cells = Array.from(grid.getElementsByClassName('mosaic-cell'));
            
            const startPos = startCell.dataset.position.split('-').map(Number);
            const endPos = endCell.dataset.position.split('-').map(Number);
            
            const minRow = Math.min(startPos[0], endPos[0]);
            const maxRow = Math.max(startPos[0], endPos[0]);
            const minCol = Math.min(startPos[1], endPos[1]);
            const maxCol = Math.max(startPos[1], endPos[1]);
            
            return cells.filter(cell => {
                const [row, col] = cell.dataset.position.split('-').map(Number);
                return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;
            });
        }
        
        // Create mosaic grid
        function createGrid(autoPopulate = false, width = null, height = null) {
            const gridWidth = width || 42;
            const gridHeight = height || 67;
            
            const container = document.getElementById('mosaicContainer');
            container.innerHTML = '';
            originalColors.clear();
            
            const grid = document.createElement('div');
            grid.className = 'mosaic-grid';
            
            for (let row = 0; row < gridHeight; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'mosaic-row';
                
                for (let col = 0; col < gridWidth; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'mosaic-cell';
                    const pos = `${row}-${col}`;
                    cell.dataset.position = pos;
                    
                    // Mouse event handlers for selection
                    cell.addEventListener('mousedown', (e) => {
                        if (!e.button === 0) return; // Left click only
                        isSelecting = true;
                        selectionStart = cell;
                        createSelectionOverlay();
                        updateSelectionOverlay(cell, cell);
                        e.preventDefault(); // Prevent text selection
                    });
                    
                    cell.addEventListener('mousemove', (e) => {
                        if (!isSelecting) return;
                        updateSelectionOverlay(selectionStart, cell);
                    });
                    
                    cell.addEventListener('mouseup', () => {
                        if (!isSelecting) return;
                        const selectedCells = getCellsInSelection(selectionStart, cell);
                        selectedCells.forEach(selectedCell => {
                            paintCell(selectedCell);
                        });
                        isSelecting = false;
                        removeSelectionOverlay();
                        updateColorCounts();
                    });
                    
                    if (autoPopulate && imageData) {
                        const imgX = Math.floor((col / gridWidth) * imageData.width);
                        const imgY = Math.floor((row / gridHeight) * imageData.height);
                        const pixelIndex = (imgY * imageData.width + imgX) * 4;
                        
                        const pixelColor = [
                            imageData.data[pixelIndex],
                            imageData.data[pixelIndex + 1],
                            imageData.data[pixelIndex + 2]
                        ];
                        
                        originalColors.set(pos, pixelColor);
                        
                        const closestColorIndex = findClosestTileColor(pixelColor);
                        const tileColor = tileColors[closestColorIndex];
                        cell.style.backgroundColor = `rgb(${tileColor[0]}, ${tileColor[1]}, ${tileColor[2]})`;
                    }
                    
                    rowDiv.appendChild(cell);
                }
                
                grid.appendChild(rowDiv);
            }
            
            container.appendChild(grid);
            updateColorCounts();
        }
        
        function paintCell(cell) {
            const color = tileColors[selectedColorIndex];
            cell.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        }
        
        // Add global mouse event handlers
        document.addEventListener('mouseup', () => {
            isSelecting = false;
            removeSelectionOverlay();
        });
        
        document.addEventListener('mouseleave', () => {
            isSelecting = false;
            removeSelectionOverlay();
        });
        
        // Initialize the page
        initColorPalette();
        createGrid();
    </script>
</body>
</html> 